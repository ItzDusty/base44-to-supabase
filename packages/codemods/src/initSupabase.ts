import fs from 'node:fs/promises';
import path from 'node:path';

import type { Base44ToSupabaseReport } from './report.js';
import { toPosixPath } from './fs.js';

export type InitSupabaseOptions = {
  rootPath: string;
  report: Base44ToSupabaseReport;
  schema?: {
    ownerColumn?: string | null;
    includeUpdatedAt?: boolean;
  };
  edgeFunctions?: {
    generate?: boolean;
    functionsDir?: string;
  };
};

function nowStamp(): string {
  const d = new Date();
  const pad = (n: number) => String(n).padStart(2, '0');
  return `${d.getUTCFullYear()}${pad(d.getUTCMonth() + 1)}${pad(d.getUTCDate())}${pad(
    d.getUTCHours(),
  )}${pad(d.getUTCMinutes())}${pad(d.getUTCSeconds())}`;
}

function sqlIdent(name: string): string {
  return `"${name.replaceAll('"', '""')}"`;
}

function toSqlType(field: string): string {
  // Conservative default. Users should refine types after initial migration.
  void field;
  return 'text';
}

export async function initSupabaseProject(
  options: InitSupabaseOptions,
): Promise<Base44ToSupabaseReport> {
  const rootPath = path.resolve(options.rootPath);
  const report = options.report;

  const ownerColumn = options.schema?.ownerColumn ?? null;
  const includeUpdatedAt = options.schema?.includeUpdatedAt ?? false;
  const shouldGenerateEdgeFunctions = options.edgeFunctions?.generate ?? false;
  const functionsDirRel =
    options.edgeFunctions?.functionsDir ?? toPosixPath(path.join('supabase', 'functions'));

  const supabaseDir = path.join(rootPath, 'supabase');
  const migrationsDir = path.join(supabaseDir, 'migrations');
  const policiesDir = path.join(supabaseDir, 'policies');

  await fs.mkdir(migrationsDir, { recursive: true });
  await fs.mkdir(policiesDir, { recursive: true });

  const stamp = nowStamp();
  const migrationPath = path.join(migrationsDir, `${stamp}_base44_to_supabase.sql`);
  const policyPath = path.join(policiesDir, `${stamp}_rls_templates.sql`);
  const seedPath = path.join(supabaseDir, 'seed.sql');

  const entities = report.inferred.entities;

  const migrationSql: string[] = [];
  migrationSql.push(`-- Generated by base44-to-supabase on ${new Date().toISOString()}`);
  migrationSql.push(`-- Review and edit before applying.`);
  migrationSql.push('');

  for (const entity of entities) {
    const cols: string[] = [];
    cols.push(`id uuid primary key default gen_random_uuid()`);
    if (ownerColumn) cols.push(`${sqlIdent(ownerColumn)} uuid`);
    for (const field of entity.fields) cols.push(`${sqlIdent(field)} ${toSqlType(field)}`);
    cols.push(`created_at timestamptz not null default now()`);
    if (includeUpdatedAt) cols.push(`updated_at timestamptz not null default now()`);

    migrationSql.push(`create table if not exists ${sqlIdent(entity.name)} (`);
    for (let i = 0; i < cols.length; i++) {
      const line = cols[i];
      const comma = i === cols.length - 1 ? '' : ',';
      migrationSql.push(`  ${line}${comma}`);
    }
    migrationSql.push(');');
    migrationSql.push(`alter table ${sqlIdent(entity.name)} enable row level security;`);
    migrationSql.push('');
  }

  const policySql: string[] = [];
  policySql.push(`-- Safe-by-default RLS templates (generated by base44-to-supabase).`);
  policySql.push(`-- These are templates: adjust to match your authorization model.`);
  policySql.push('');

  for (const entity of entities) {
    policySql.push(`-- Example: allow authenticated users to read rows`);
    policySql.push(
      `-- create policy "${entity.name}_read_authenticated" on ${sqlIdent(entity.name)}`,
    );
    policySql.push(`-- for select to authenticated using (true);`);
    policySql.push('');

    if (ownerColumn) {
      policySql.push(
        `-- Example: allow users to insert their own rows (requires a ${ownerColumn} column)`,
      );
      policySql.push(`-- create policy "${entity.name}_insert_own" on ${sqlIdent(entity.name)}`);
      policySql.push(
        `-- for insert to authenticated with check (auth.uid() = ${sqlIdent(ownerColumn)});`,
      );
      policySql.push('');
    }
  }

  const seedSql: string[] = [];
  seedSql.push(`-- Optional seed data (generated by base44-to-supabase).`);
  seedSql.push(`-- Add inserts here once your schema is finalized.`);
  seedSql.push('');

  await fs.writeFile(migrationPath, migrationSql.join('\n'), 'utf8');
  await fs.writeFile(policyPath, policySql.join('\n'), 'utf8');
  await fs.writeFile(seedPath, seedSql.join('\n'), 'utf8');

  const edgeFunctionsGenerated: string[] = [];
  if (shouldGenerateEdgeFunctions && report.inferred.serverFunctions.length) {
    const functionsDirAbs = path.join(rootPath, ...functionsDirRel.split('/'));
    await fs.mkdir(functionsDirAbs, { recursive: true });

    for (const fn of report.inferred.serverFunctions) {
      const fnDir = path.join(functionsDirAbs, fn.name);
      await fs.mkdir(fnDir, { recursive: true });
      const fnIndex = path.join(fnDir, 'index.ts');
      await fs.writeFile(
        fnIndex,
        `// Generated by base44-to-supabase.
// TODO: Implement this function based on your app's server-side logic.
// Supabase Edge Functions typically run on Deno.

import { serve } from 'https://deno.land/std@0.224.0/http/server.ts';

serve((_req) => {
  return new Response(JSON.stringify({ error: 'Not implemented' }), {
    status: 501,
    headers: { 'content-type': 'application/json' },
  });
});
`,
        'utf8',
      );

      edgeFunctionsGenerated.push(toPosixPath(path.relative(rootPath, fnIndex)));
    }
  }

  report.initSupabase = {
    supabaseDir: toPosixPath(path.relative(rootPath, supabaseDir)),
    migrationsGenerated: [toPosixPath(path.relative(rootPath, migrationPath))],
    policiesGenerated: [toPosixPath(path.relative(rootPath, policyPath))],
    seedGenerated: toPosixPath(path.relative(rootPath, seedPath)),
    edgeFunctionsGenerated: edgeFunctionsGenerated.length ? edgeFunctionsGenerated : undefined,
  };

  return report;
}
